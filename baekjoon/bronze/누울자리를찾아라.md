[![백준](../백준표지.jpg)](https://www.acmicpc.net/problem/1652)
# [👩🏻‍💻문제링크](https://www.acmicpc.net/problem/1652)

[프로그래머스 1652] 누울 자리를 찾아라 (Javascript)

문제
일 년 동안 세계일주를 하던 영식이는 여행을 하다 너무 피곤해서 근처에 있는 코레스코 콘도에서 하룻밤 잠을 자기로 하고 방을 잡았다.

코레스코 콘도에 있는 방은 NxN의 정사각형모양으로 생겼다. 방 안에는 옮길 수 없는 짐들이 이것저것 많이 있어서 영식이의 누울 자리를 차지하고 있었다. 영식이는 이 열악한 환경에서 누울 수 있는 자리를 찾아야 한다. 영식이가 누울 수 있는 자리에는 조건이 있다. 똑바로 연속해서 2칸 이상의 빈 칸이 존재하면 그 곳에 몸을 양 옆으로 쭉 뻗으면서 누울 수 있다. 가로로 누울 수도 있고 세로로 누울 수도 있다. 누울 때는 무조건 몸을 쭉 뻗기 때문에 반드시 벽이나 짐에 닿게 된다. (중간에 어정쩡하게 눕는 경우가 없다.)

만약 방의 구조가 위의 그림처럼 생겼다면, 가로로 누울 수 있는 자리는 5개이고, 세로로 누울 수 있는 자리는 4개 이다. 방의 크기 N과 방의 구조가 주어졌을 때, 가로로 누울 수 있는 자리와 세로로 누울 수 있는 자리의 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 방의 크기 N이 주어진다. N은 1이상 100이하의 정수이다. 그 다음 N줄에 걸쳐 N개의 문자가 들어오는데 '.'은 아무것도 없는 곳을 의미하고, 'X'는 짐이 있는 곳을 의미한다.

출력
첫째 줄에 가로로 누울 수 있는 자리와 세로로 누울 수 있는 자리의 개수를 출력한다.

예제 입력 1 
5
....X
..XX.
.....
.XX..
X....

예제 출력 1 
5 4

<br>

# ✍️Idea Sketch

### **2021-07-17**

#### 1. 로직
- 연속 2칸 이상의 빈 칸이 존재하면 눕는다.
- **누울 때는 무조건 몸을 쭉 뻗기 때문에 반드시 벽이나 짐에 닿는다!!**

#### 2. 가로로 누울 수 있는 자리
- 문자열을 X기준으로 나눈 후, includes()로 ..이 있는지 확인
```javascript
    input[i].split('X').forEach(v => {
      if (v.includes('..')) row++;
    })
```
- filter() 사용
```javascript
row += input[i].split('X').filter(v => v.includes('..')).length;
```

#### 3. 세로로 누울 수 있는 자리
- .을 카운트
- X가 나오면 초기화

#### 4. 2개 이상일 때 1번만 카운트 해야하는데...
- for문 시작하기 전에 카운트하기 (X) --> 세로로 누울 수 있는 자리 마지막 경우를 카운트하지 못함
- 짐 또는 벽에 닿았을 때 column +1



<br>

# ✍️소스코드

### **2021-07-17 실패**
- 원인 : 2칸 빈칸이 존재하기만 하면 +1하고 바로 다음차례로 넘어감
- But 누울 수 있는 자리가 여러개일 수 있음

> *반례* 
..X..일 경우 누울 수 있는 자리는 1개가 아니라 2개
<br>

```javascript
function solution(count, input) {
  let row = 0, column = 0; 

  for (let i=0; i<count; i++) {
    if (input[i].includes('..')) row++; 
    
    for (let j=0; j<count; j++) {
      if (i === 0) continue;
      if (input[i-1][j] === '.' && input[i][j] === '.') {
        column++;
        break;
      }
    }
  }

  return `${row} ${column}`
}
```

<br>

### **2021-07-17 통과**

```javascript
let fs = require('fs');
let input = fs.readFileSync('../stdin').toString().split('\n');
let count = input.shift();

function solution(count, input) {
  let row = 0, column = 0; 

  for (let i=0; i<count; i++) {
    row += input[i].split('X').filter(v => v.includes('..')).length;

    let columnCount = 0;  // 세로로 연속하는 빈 칸의 수
    for (let j=0; j<count; j++) {
      if (input[j][i] === '.') columnCount++;
      if (input[j][i] === 'X' || j === count - 1) {  // 짐이나 벽에 닿았을 때
        if (columnCount >= 2) column++;
        columnCount = 0;
      }
    }
  }

  return `${row} ${column}`
}

console.log(solution(count, input));

```